import{_ as t,c as a,a3 as i,o}from"./chunks/framework.ohJJpums.js";const n="/concepts/design-patterns/dp-adapter.png",r="/concepts/design-patterns/dp-bridge.png",d="/concepts/design-patterns/dp-deco.png",s="/concepts/design-patterns/dp-mvc.png",l="/concepts/design-patterns/dp-mvvm.png",b=JSON.parse('{"title":"Structural Patterns","description":"","frontmatter":{},"headers":[],"relativePath":"articles/concepts/design-patterns/structural-patterns.md","filePath":"articles/concepts/design-patterns/structural-patterns.md"}'),c={name:"articles/concepts/design-patterns/structural-patterns.md"};function h(p,e,u,f,m,w){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="structural-patterns" tabindex="-1">Structural Patterns <a class="header-anchor" href="#structural-patterns" aria-label="Permalink to &quot;Structural Patterns&quot;">â€‹</a></h1><p><em>Last Updated: Dec 7, 2024</em></p><p>Structural patterns help organize and manage relationships between objects to form larger structures and enhance flexibility and reusability.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>I am only listing the ones that I&#39;ve been dealing with or interact with a couple of times ðŸ˜ƒ</p></div><h2 id="tl-dr" tabindex="-1">TL;DR <a class="header-anchor" href="#tl-dr" aria-label="Permalink to &quot;TL;DR&quot;">â€‹</a></h2><ul><li><code>Adapter</code>: Makes incompatible interfaces compatible by acting as a translator.</li><li><code>Bridge</code>: Separates an abstraction from its implementation, letting both vary independently.</li><li><code>Decorator</code>: Adds extra features to an object dynamically, like layers on top of the base.</li><li><code>Model-View-Controller</code>: Separates data, interface, and control logic for organized structure.</li><li><code>Model-View-ViewModel</code>: Enhances MVC by adding a ViewModel, which acts as a bridge between Model and View, allowing data binding and cleaner separation of business logic and UI.</li></ul><h2 id="adapter-pattern" tabindex="-1">Adapter Pattern <a class="header-anchor" href="#adapter-pattern" aria-label="Permalink to &quot;Adapter Pattern&quot;">â€‹</a></h2><h3 id="definition" tabindex="-1">Definition <a class="header-anchor" href="#definition" aria-label="Permalink to &quot;Definition&quot;">â€‹</a></h3><p>The <code>Adapter Pattern</code> helps two pieces of code with different interfqces work together. Itâ€™s commonly used when integrating third-party libraries or legacy code that doesn&#39;t match the expected interface.</p><div style="display:flex;justify-content:center;"><img src="'+n+'" alt="Diagram representing how the Adapter design pattern works"></div><p>Think about when you are traveling: when you decide to travel to a different continent, it&#39;s complicated to use a power outlet! That&#39;s where the plug adapter comes in, and helps you to adapt your charger. Same here!</p><h3 id="flow" tabindex="-1">Flow <a class="header-anchor" href="#flow" aria-label="Permalink to &quot;Flow&quot;">â€‹</a></h3><ul><li><code>Adapter Creation</code>: The adapter class is created, implementing the interface and methods expected by the client.</li><li><code>Adaptation</code>: The adapter translates or maps requests from the client interface to the adaptee&#39;s interface.</li><li><code>Usage</code>: The client can now use the adapter as if it were using the original system or class.</li></ul><p>-&gt; So, an adapter class sits between two incompatible parts, takes requests from one part, translates it, and sends it to the other part, so it can understand.</p><h2 id="bridge-pattern" tabindex="-1">Bridge Pattern <a class="header-anchor" href="#bridge-pattern" aria-label="Permalink to &quot;Bridge Pattern&quot;">â€‹</a></h2><h3 id="definition-1" tabindex="-1">Definition <a class="header-anchor" href="#definition-1" aria-label="Permalink to &quot;Definition&quot;">â€‹</a></h3><p>The <code>Birdge Pattern</code> helps split an abstraction (a high-level idea) from its implementation (the details). Need an example? I got one for you: suppose you have a magic remote that controls a devices such as different TVs. Well, the abstraction is the remote, and the remote is used by implementations such as the TVs.</p><div style="display:flex;justify-content:center;"><img src="'+r+'" alt="Diagram representing how the Bridge design pattern works"></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The relation Has-A defines the bridge between the two hierarchies (Remote and TV)</p></div><h3 id="flow-1" tabindex="-1">Flow <a class="header-anchor" href="#flow-1" aria-label="Permalink to &quot;Flow&quot;">â€‹</a></h3><ul><li><code>Abstraction</code>: Defines a high-level interface, often extendeed by refined abstractions.</li><li><code>Implementation</code>: Concrete implementations are separated into their own classes.</li><li><code>Usage</code>: The abstraction delegates operations to the implementation, allowing both to evolve independetly.</li></ul><p>-&gt; We got two parts: one for general controle (the remote), and one for the specific device (the TV, the Radio). The remote sends signals, but each device responds its way.</p><h2 id="decorator-pattern" tabindex="-1">Decorator Pattern <a class="header-anchor" href="#decorator-pattern" aria-label="Permalink to &quot;Decorator Pattern&quot;">â€‹</a></h2><h3 id="definition-2" tabindex="-1">Definition <a class="header-anchor" href="#definition-2" aria-label="Permalink to &quot;Definition&quot;">â€‹</a></h3><p>The <code>Decorator Pattern</code> lets you add new features or &quot;decorations&quot; to an object ithout changing its structure. It&#39;s like adding extra toppings on a pizzaâ€“the pizza stays the same, but you add things to it!</p><div style="display:flex;justify-content:center;"><img src="'+d+'" alt="Diagram representing how the Decorator design pattern works"></div><h3 id="flow-2" tabindex="-1">Flow <a class="header-anchor" href="#flow-2" aria-label="Permalink to &quot;Flow&quot;">â€‹</a></h3><ul><li><code>Component Interface</code>: Defines the base interface for objects that can have responsibilities added.</li><li><code>Concrete Component</code>: The object being decorated.</li><li><code>Decorator</code>: Wraps the component, adding new behavior while conforming to the same interface.</li><li><code>Usage</code>: Multiple decorators can be stacked to add layered behaviors dynamically.</li></ul><p>-&gt; You have a basic object (like a plain pizza), and then you can wrap it with decorators (extra cheese, pepperoni) that add extra functionality or features. Each decorator adds something new.</p><h2 id="model-view-controller-mvc" tabindex="-1">Model-View-Controller (MVC) <a class="header-anchor" href="#model-view-controller-mvc" aria-label="Permalink to &quot;Model-View-Controller (MVC)&quot;">â€‹</a></h2><h3 id="definition-3" tabindex="-1">Definition <a class="header-anchor" href="#definition-3" aria-label="Permalink to &quot;Definition&quot;">â€‹</a></h3><p>The <code>MVC</code> is a fundamental design pattern in iOS development. It seperates the data (Model), user interface (View), and the logic that connects them (Controller).</p><ul><li>The <code>Model</code> represents the data and business logic of the application. It is responsible for retrieveing data, managing it, and notifying the View when data changes.</li><li>The <code>View</code> displays the user interface and presents the data to the user.It listens for user input and forwards these actions to the Controller.</li><li>The <code>Controller</code> acts as am intermediary between the Model and the View. Receives input from the View, processes it (often involving calls to the Model), and upadtes the View accordingly.</li></ul><h3 id="flow-3" tabindex="-1">Flow <a class="header-anchor" href="#flow-3" aria-label="Permalink to &quot;Flow&quot;">â€‹</a></h3><div style="display:flex;justify-content:center;"><img src="'+s+'" alt="Diagram representing how the MVC design pattern works"></div><ul><li>The <code>View</code> receives user input (1) and notifies the <code>Controller</code> (1ðŸ””).</li><li>The <code>Controller</code> interacts with the <code>Model</code> to get or update data (2).</li><li>Once the <code>Model</code> is updated of fetched (ðŸ”„3), the <code>Controller</code> updates the <code>View</code> (3).</li></ul><h2 id="model-view-viewmodel-mvvm" tabindex="-1">Model-View-ViewModel (MVVM) <a class="header-anchor" href="#model-view-viewmodel-mvvm" aria-label="Permalink to &quot;Model-View-ViewModel (MVVM)&quot;">â€‹</a></h2><h3 id="definition-4" tabindex="-1">Definition <a class="header-anchor" href="#definition-4" aria-label="Permalink to &quot;Definition&quot;">â€‹</a></h3><p>The <code>MVVM</code> enhances the MVC pattern with a <code>ViewModel</code> layer that separates business logic from the View.</p><ul><li>The <code>Model</code> is similar to MVC, which represents the data and business logic of the application.</li><li>The <code>View</code> displays the user interface and binds to properties exposed by the ViewModel.</li><li>The <code>ViewModel</code> acts as an intermediary between the Model and the View, and exposes data in a way that the View can easily consume. It provides properties that the View can bind to, and it may include methods that the View can invoke without needing to know the specifics of the Model.</li></ul><h3 id="flow-4" tabindex="-1">Flow <a class="header-anchor" href="#flow-4" aria-label="Permalink to &quot;Flow&quot;">â€‹</a></h3><div style="display:flex;justify-content:center;"><img src="'+l+'" alt="Diagram representing how the MVC design pattern works"></div><ul><li>The <code>View</code> binds to properties in the <code>ViewModel</code> (1).</li><li>When the <code>ViewModel</code> receives updates from the <code>Model</code> or processes user input, it notifies the <code>View</code> of changes (2).</li><li>The <code>View</code> updates automatically based on the data bound to the <code>ViewModel</code> (3).</li></ul>',43)]))}const y=t(c,[["render",h]]);export{b as __pageData,y as default};
